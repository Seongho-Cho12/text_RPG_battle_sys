============================================================
[FAIL] tests/test_phase23_skill_chain_and_cooldown.py::test_attack_result_rank_is_observable_via_chain_thresholds
------------------------------------------------------------
[EXPERIMENT]
ATTACK 결과가 0/1/2/3으로 매핑되는지 간접 검증:
    - require_prev_gte=2(STRONG 이상) step이 실행되는 seed를 찾는다.
    - require_prev_gte=3(CRITICAL) step이 실행되는 seed를 찾는다.


[TRACEBACK]
def test_attack_result_rank_is_observable_via_chain_thresholds():
        """
        ATTACK 결과가 0/1/2/3으로 매핑되는지 간접 검증:
        - require_prev_gte=2(STRONG 이상) step이 실행되는 seed를 찾는다.
        - require_prev_gte=3(CRITICAL) step이 실행되는 seed를 찾는다.
        """
        eng, bs, A1, E1 = _mk_engine_1v1()
    
        # ATTACK 후, rank가 충분하면 HP_DELTA를 수행하도록 만든다(눈에 보이게).
        # - STRONG 이상이면 E1에 -1
        # - CRITICAL이면 추가로 -1 (총 -2)
        skill = Skill(
            skill_id="rank_gate",
            name="RankGate",
            actor=A1,
            action_type="MAIN",
            cooldown_turns=0,
            steps=[
                Step(kind="ATTACK", target=E1),
                Step(kind="APPLY_HP_DELTA", target=E1, hp_delta=-1, require_prev_gte=2),
                Step(kind="APPLY_HP_DELTA", target=E1, hp_delta=-1, require_prev_gte=3),
            ],
        )
    
        strong_seed = None
        crit_seed = None
    
        for seed in range(0, 5000):
            eng, bs, A1, E1 = _mk_engine_1v1()
            random.seed(seed)
            hp0 = bs.combatants[E1].hp
            out = eng.apply_skill(bs, skill)
            hp1 = bs.combatants[E1].hp
    
            # STRONG gate(-1)만 열리면 hp 감소량에 1 포함
            # CRITICAL gate까지 열리면 hp 감소량에 2 포함
            delta = hp0 - hp1
    
            if strong_seed is None:
                # strong gate가 실행되었다는 로그로 확인(가장 확실)
                if any("HP_DELTA:" in e for e in out.events) and any("require_prev_gte=2" not in e for e in out.events):
                    # 로그만으로는 gate 종류를 정확히 분리하기 어려우니, delta로 판별
                    if delta >= 1:
                        # 추가 데미지(기본 공격 dmg)도 섞이므로, "HP_DELTA 라인 개수"로 게이트 확인
                        hp_delta_lines = [e for e in out.events if e.startswith("HP_DELTA:")]
                        if len(hp_delta_lines) >= 1:
                            strong_seed = seed
    
            if crit_seed is None:
                hp_delta_lines = [e for e in out.events if e.startswith("HP_DELTA:")]
                if len(hp_delta_lines) >= 2:
                    crit_seed = seed
    
            if strong_seed is not None and crit_seed is not None:
                break
    
        assert strong_seed is not None, "STRONG(>=2) seed not found"
>       assert crit_seed is not None, "CRITICAL(>=3) seed not found"
E       AssertionError: CRITICAL(>=3) seed not found
E       assert None is not None

tests\test_phase23_skill_chain_and_cooldown.py:262: AssertionError
============================================================
[PASS] tests/test_phase23_skill_chain_and_cooldown.py::test_skill_cooldown_is_skill_level_not_step_level_and_blocks_next_own_turn
------------------------------------------------------------
[EXPERIMENT]
쿨타임은 스텝이 아니라 스킬 단위로 처리되어야 하며,
    1턴 쿨다운이면 다음 '자기 턴'에 막히고, 그 다음 턴에는 풀려야 한다.
    (1v1 기준: cd_ticks = turns_to_ticks_for_battle(1) = 1*2 + 1 = 3 라는 전제)

[CAPTURED OUTPUT]
[Captured stdout call]
SLOT: MAIN used by A1
STEP: ATTACK A1->E1 outcome=WEAK dmg=1
COOLDOWN_SET: A1 skill=cooldown_test turns=1 ticks=3
SLOT: MAIN used by A1
STEP: ATTACK A1->E1 outcome=EVADE dmg=0
COOLDOWN_SET: A1 skill=cooldown_test turns=1 ticks=3


