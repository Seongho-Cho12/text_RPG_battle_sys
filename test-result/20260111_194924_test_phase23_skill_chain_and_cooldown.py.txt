============================================================
[PASS] tests/test_phase23_skill_chain_and_cooldown.py::test_skill_chain_attack_evade_breaks_and_skips_next_steps
------------------------------------------------------------
[EXPERIMENT]
공격이 EVADE(0)이면 require_prev_gte=1인 다음 step들은 실행되지 않고 체인이 끊겨야 한다.

[CAPTURED OUTPUT]
[Captured stdout call]
[CHAIN EVADE] seed=0
SLOT: MAIN used by A1
STEP: ATTACK A1->E1 outcome=EVADE dmg=0
STEP_SKIPPED: kind=APPLY_EFFECT require_prev_gte=1 prev=0
CHAIN_BREAK


============================================================
[PASS] tests/test_phase23_skill_chain_and_cooldown.py::test_skill_chain_attack_hit_allows_next_step_and_effect_may_apply
------------------------------------------------------------
[EXPERIMENT]
공격 결과가 1 이상이면(WEAK/STRONG/CRITICAL) 다음 APPLY_EFFECT가 실행(시도)되어야 한다.
    성공/실패는 status roll에 따름(둘 다 가능).

[CAPTURED OUTPUT]
[Captured stdout call]
[CHAIN HIT] seed=1
STEP: ATTACK A1->E1 outcome=WEAK dmg=1
SLOT: MAIN used by A1
STEP: ATTACK A1->E1 outcome=WEAK dmg=1
STATUS_CHECK: A1->E1 effect=BLEEDING inflict=30 resist=15 resistible=True roll=17 success=True
EFFECT_APPLIED: E1 +BLEEDING(turns=2, ticks=+5, total_ticks=5)


============================================================
[PASS] tests/test_phase23_skill_chain_and_cooldown.py::test_skill_chain_status_success_required_for_modifier
------------------------------------------------------------
[EXPERIMENT]
APPLY_EFFECT 성공(1)일 때만 다음 APPLY_MODIFIER가 실행되도록 검증.
    - apply_effect가 실패하면(0) 체인 끊기 -> modifier 미적용.

[CAPTURED OUTPUT]
[Captured stdout call]
[STATUS->MOD success] seed=31
SLOT: SUB used by A1
STATUS_CHECK: A1->E1 effect=BLEEDING inflict=1 resist=15 resistible=True roll=1 success=True
EFFECT_APPLIED: E1 +BLEEDING(turns=2, ticks=+5, total_ticks=5)
MOD_APPLIED: E1 mid=b0fc9519cca742ca9fa9738cc10e2b72 key=WEAK delta=-10 turns=2 ticks=5
[STATUS->MOD fail] seed=0
SLOT: SUB used by A1
STATUS_CHECK: A1->E1 effect=BLEEDING inflict=1 resist=15 resistible=True roll=13 success=False
EFFECT_RESISTED: E1 resisted BLEEDING
STEP_SKIPPED: kind=APPLY_MODIFIER require_prev_gte=1 prev=0
CHAIN_BREAK


============================================================
[FAIL] tests/test_phase23_skill_chain_and_cooldown.py::test_attack_result_rank_is_observable_via_chain_thresholds
------------------------------------------------------------
[EXPERIMENT]
ATTACK 결과가 0/1/2/3으로 매핑되는지 간접 검증:
    - require_prev_gte=2(STRONG 이상) step이 실행되는 seed를 찾는다.
    - require_prev_gte=3(CRITICAL) step이 실행되는 seed를 찾는다.


[TRACEBACK]
def test_attack_result_rank_is_observable_via_chain_thresholds():
        """
        ATTACK 결과가 0/1/2/3으로 매핑되는지 간접 검증:
        - require_prev_gte=2(STRONG 이상) step이 실행되는 seed를 찾는다.
        - require_prev_gte=3(CRITICAL) step이 실행되는 seed를 찾는다.
        """
        eng, bs, A1, E1 = _mk_engine_1v1()
    
        # ATTACK 후, rank가 충분하면 HP_DELTA를 수행하도록 만든다(눈에 보이게).
        # - STRONG 이상이면 E1에 -1
        # - CRITICAL이면 추가로 -1 (총 -2)
        skill = Skill(
            skill_id="rank_gate",
            name="RankGate",
            actor=A1,
            action_type="MAIN",
            cooldown_turns=0,
            steps=[
                Step(kind="ATTACK", target=E1),
                Step(kind="APPLY_HP_DELTA", target=E1, hp_delta=-1, require_prev_gte=2),
                Step(kind="APPLY_HP_DELTA", target=E1, hp_delta=-1, require_prev_gte=3),
            ],
        )
    
        strong_seed = None
        crit_seed = None
    
        for seed in range(0, 5000):
            eng, bs, A1, E1 = _mk_engine_1v1()
            random.seed(seed)
            hp0 = bs.combatants[E1].hp
            out = eng.apply_skill(bs, skill)
            hp1 = bs.combatants[E1].hp
    
            # STRONG gate(-1)만 열리면 hp 감소량에 1 포함
            # CRITICAL gate까지 열리면 hp 감소량에 2 포함
            delta = hp0 - hp1
    
            if strong_seed is None:
                # strong gate가 실행되었다는 로그로 확인(가장 확실)
                if any("HP_DELTA:" in e for e in out.events) and any("require_prev_gte=2" not in e for e in out.events):
                    # 로그만으로는 gate 종류를 정확히 분리하기 어려우니, delta로 판별
                    if delta >= 1:
                        # 추가 데미지(기본 공격 dmg)도 섞이므로, "HP_DELTA 라인 개수"로 게이트 확인
                        hp_delta_lines = [e for e in out.events if e.startswith("HP_DELTA:")]
                        if len(hp_delta_lines) >= 1:
                            strong_seed = seed
    
            if crit_seed is None:
                hp_delta_lines = [e for e in out.events if e.startswith("HP_DELTA:")]
                if len(hp_delta_lines) >= 2:
                    crit_seed = seed
    
            if strong_seed is not None and crit_seed is not None:
                break
    
        assert strong_seed is not None, "STRONG(>=2) seed not found"
>       assert crit_seed is not None, "CRITICAL(>=3) seed not found"
E       AssertionError: CRITICAL(>=3) seed not found
E       assert None is not None

tests\test_phase23_skill_chain_and_cooldown.py:263: AssertionError
============================================================
[PASS] tests/test_phase23_skill_chain_and_cooldown.py::test_skill_cooldown_is_skill_level_not_step_level_and_blocks_next_own_turn
------------------------------------------------------------
[EXPERIMENT]
쿨타임은 스텝이 아니라 스킬 단위로 처리되어야 하며,
    1턴 쿨다운이면 다음 '자기 턴'에 막히고, 그 다음 턴에는 풀려야 한다.
    (1v1 기준: cd_ticks = turns_to_ticks_for_battle(1) = 1*2 + 1 = 3 라는 전제)

[CAPTURED OUTPUT]
[Captured stdout call]
SLOT: MAIN used by A1
STEP: ATTACK A1->E1 outcome=WEAK dmg=1
COOLDOWN_SET: A1 skill=cooldown_test turns=1 ticks=3
SLOT: MAIN used by A1
STEP: ATTACK A1->E1 outcome=EVADE dmg=0
COOLDOWN_SET: A1 skill=cooldown_test turns=1 ticks=3


